<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RAC中将冷信号转为热信号]]></title>
    <url>%2F2017%2F07%2F15%2FRAC%E4%B8%AD%E5%B0%86%E5%86%B7%E4%BF%A1%E5%8F%B7%E8%BD%AC%E4%B8%BA%E7%83%AD%E4%BF%A1%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[我在之前一篇文章说到过冷信号带来的问题, 有时候通过将其转为热信号就可以避免, 这篇文章将会介绍如何将一个冷信号转为热信号。 方式1: subscribe 直接上代码吧 RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@&quot;signal&quot;]; return nil;&#125;];RACSubject *subject = [RACSubject subject];[subject subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;%@&quot;,x);&#125;];[signal1 subscribe:subject]; 首先RACSubject 是遵守 RACSubscriber 协议的，所以我们可以将 subject 当作 subscriber 传入subscribe方法中。subscripe 的实现如下 - (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123; NSCParameterAssert(subscriber != nil); RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable]; subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable]; if (self.didSubscribe != NULL) &#123; RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123; RACDisposable *innerDisposable = self.didSubscribe(subscriber); [disposable addDisposable:innerDisposable]; &#125;]; [disposable addDisposable:schedulingDisposable]; &#125; return disposable;&#125; 可以看到 self.didSubscribe(subscriber); 这里 调用了signal 的 didSubscribe 这个block ，并且将 subscriber(也就是subject) 作为参数传入。 看过上篇文章你就会知道，第一段代码中block会被执行，也就是 [subscriber sendNext:@&quot;signal&quot;]; 也会被执行，这里的subscriber其实还是我们创建的subject，这样的话，第一段代码其实可以简化为 RACSubject *subject = [RACSubject subject];[subject subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;%@&quot;,x);&#125;];[subject sendNext:@&quot;signal&quot;]; 不过平时我们不会这么去使用，RACSignal+Operationsn 这个类别中提供了更多优良姿势，下面一一介绍。 方式2: multicast用法如下： RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@&quot;signal1&quot;]; return nil;&#125;];RACSubject *subject1 = [RACSubject subject];RACMulticastConnection *connection = [signal1 multicast:subject1];[connection.signal subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;%@&quot;,x);&#125;];[connection connect]; 首先我们看一下 muticast 的实现 - (RACMulticastConnection *)multicast:(RACSubject *)subject &#123; [subject setNameWithFormat:@&quot;[%@] -multicast: %@&quot;, self.name, subject.name]; RACMulticastConnection *connection = [[RACMulticastConnection alloc] initWithSourceSignal:self subject:subject]; return connection;&#125;- (instancetype)initWithSourceSignal:(RACSignal *)source subject:(RACSubject *)subject &#123; NSCParameterAssert(source != nil); NSCParameterAssert(subject != nil); self = [super init]; _sourceSignal = source; _serialDisposable = [[RACSerialDisposable alloc] init]; _signal = subject; return self;&#125; 其实就是生成了一个 RACMulticastConnection 实例，并将 signal(sourceSignal) 和 subject(signal) 分别保存起来。所以，下面对 connection.signal 的订阅 就是对subject的订阅。 接下来再来看一下 connect 的实现 - (RACDisposable *)connect &#123; BOOL shouldConnect = OSAtomicCompareAndSwap32Barrier(0, 1, &amp;_hasConnected); if (shouldConnect) &#123; self.serialDisposable.disposable = [self.sourceSignal subscribe:_signal]; &#125; return self.serialDisposable;&#125; 可以看到 [self.sourceSignal subscribe:_signal]; 这里其实就是 [signal subscripe:subject] 不再多说。这里有必要说一下 OSAtomicCompareAndSwap32Barrier原型如下 bool OSAtomicCompareAndSwap32Barrier( int32_t __oldValue, int32_t __newValue, volatile int32_t *__theValue ); 如果 __theValue 的值是 __oldValue 该方法会将 __theValue 由 __oldValue 换为 __newValue 并且返回YES,而如果 __theValue 的值已经是 __newValue，则不做交换并且返回NO。因此 connect 方法中 subscribe 方法只会被执行一次。 除了connect之外，RACMulticastConnection 类中还提供了一个autoconnect方法，实现如下 - (RACSignal *)autoconnect &#123; __block volatile int32_t subscriberCount = 0; return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123; OSAtomicIncrement32Barrier(&amp;subscriberCount); RACDisposable *subscriptionDisposable = [self.signal subscribe:subscriber]; RACDisposable *connectionDisposable = [self connect]; return [RACDisposable disposableWithBlock:^&#123; [subscriptionDisposable dispose]; if (OSAtomicDecrement32Barrier(&amp;subscriberCount) == 0) &#123; [connectionDisposable dispose]; &#125; &#125;]; &#125;] setNameWithFormat:@&quot;[%@] -autoconnect&quot;, self.signal.name];&#125; 他会返回一个RACDynamicSignal ，但这个信号被订阅时执行connect方法，因此使用autoconnect的姿势如下： RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@&quot;signal1&quot;]; return nil;&#125;];RACSubject *subject1 = [RACSubject subject];RACMulticastConnection *connection = [signal1 multicast:subject1];RACSignal *autoSignal = [connection autoconnect];[autoSignal subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;%@&quot;,x);&#125;]; RACMulticastConnection 用于将一个信号的订阅分享给多个订阅者，你需要使用 [RACSignal publish] 或者 [RACSignal multicast:] 来实例RACMulticastConnection对象，并且使用 connect 或 autoconnect 来执行订阅 方式3: publish在 RACSignal+Operations 这个类别中提供了publish方法来生成RACMulticastConnection示例，实现如下： - (RACMulticastConnection *)publish &#123; RACSubject *subject = [[RACSubject subject] setNameWithFormat:@&quot;[%@] -publish&quot;, self.name]; RACMulticastConnection *connection = [self multicast:subject]; return connection;&#125; 该方法只是对 multicast 方法的一个简单封装(在内部创建一个subject并对其multicast)，使用 publish 更为方便快捷。使用如下： RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@&quot;signal1&quot;]; return nil;&#125;];RACMulticastConnection *connection = [signal publish];[connection.signal subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;%@&quot;,x);&#125;];//相当于 [subject subscribeNext:...][connection connect]; //相当于 [subject sendNext:@&quot;signal1&quot;] 在 RACSignal+Operations 中除了 multicast 与 publish 方法外，还提供了 replay 、replayLast、replayLazily 这三个方法。其实他们都是对 multicast 方法的封装 方式4: replay实现如下 - (RACSignal *)replay &#123; RACReplaySubject *subject = [[RACReplaySubject subject] setNameWithFormat:@&quot;[%@] -replay&quot;, self.name]; RACMulticastConnection *connection = [self multicast:subject]; [connection connect]; return connection.signal;&#125; publish中操作的是RACSubject并且没有执行connect方法然后返回的是connection实例，而replay是对RACReplaySubject的操作，并且执行了connect方法，返回值是RACReplaySubject的实例。那么我们接受到replay的返回值其实就是拿到了由冷信号转换得到的RACReplaySubject，由于执行过connect方法，所以这个热信号已经进行过sendnext，后续只需要对其订阅即可触发。使用如下： RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@&quot;signal1&quot;]; return nil;&#125;];RACReplaySubject *rpSubjecxt = [signal replay]; //内部已执行 [rpSubjecxt sendNext:@&quot;signal1&quot;][rpSubjecxt subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;%@&quot;,x);&#125;]; 方式5: replayLast- (RACSignal *)replayLast &#123; RACReplaySubject *subject = [[RACReplaySubject replaySubjectWithCapacity:1] setNameWithFormat:@&quot;[%@] -replayLast&quot;, self.name]; RACMulticastConnection *connection = [self multicast:subject]; [connection connect]; return connection.signal;&#125; 可以看到 replayLast 的实现与replay想比只是在对RACReplaySubject的初始化方法，这里将RACReplaySubject中valuesReceived数组的capacity设为1, 所以当这个RACReplaySubject被订阅时只会执行“在他之前的的最后一个” sendNext。 replayLast 顾名思义只会重复订阅之前最后的一条sendNext。 方式6: replayLazily- (RACSignal *)replayLazily &#123; RACMulticastConnection *connection = [self multicast:[RACReplaySubject subject]]; return [[RACSignal defer:^&#123; [connection connect]; return connection.signal; &#125;] setNameWithFormat:@&quot;[%@] -replayLazily&quot;, self.name];&#125; 和replay不同的是这里将 connect 操作 套在了 defer 方法里面(defer将RACReplaySubject用RACDynamicSignal包裹起来)。 我们来看defer的实现 + (RACSignal *)defer:(RACSignal&lt;id&gt; * (^)(void))block &#123; NSCParameterAssert(block != NULL); return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123; return [block() subscribe:subscriber]; &#125;] setNameWithFormat:@&quot;+defer:&quot;];&#125; 只有 defer 方法返回的信号被订阅之后才会执行 return [block() subscribe:subscriber]; ，将 return [block() subscribe:subscriber]; 展开就是 [connection connect];return [connection.signal subscripe:subscriber]; 因此 replayLazily 返回的信号只有在被订阅的时候才会执行 [connection.signal subscripe:subscriber]， replayLazily 叫做 replayLazily 再合适不过。 replayLazily 的使用如下: RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; [subscriber sendNext:@&quot;signal1&quot;]; [subscriber sendNext:@&quot;signal2&quot;]; return nil; &#125;];RACSignal *rplaSignal = [signal replayLazily]; [rplaSignal subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;%@&quot;,x);&#125;]; // rplaSignal 被订阅时 才会执行内部的 `[connection.signal(RACReplaySubject) subscripe:subscriber]` 操作 总结 通过冷信号subscribe一个热信号即可通过将热信号当作subscriber(订阅者)来进行sendNext等操作，也就是将冷信号转为了热信号； multicast就是基于上述原理来实现的； publish replay replayLast replayLazily 都是基于 multicast 的封装,满足上的不同使用场景。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>RAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你真的懂 weak strong dance 吗？]]></title>
    <url>%2F2017%2F05%2F18%2F%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82-weak-strong-dance-%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[在阅读这篇文章之前，首先思考如下问题： 为什么 weak strong dance 能够避免循环引用？ 为什么不直接使用weak？ 使用 weak strong dance 的正确姿势？ 本文从 weak strong dance 的 由来 用途 原理 扩展 逐步分析解答上述问题，但不仅仅只是解答问题。 由来在iOS开发中，无论objective-c还是swift都是采用引用计数来管理内存。而循环引用算是采用引用计数法管理内存中比较棘手的一个问题。在MRC时代，因为对象的引用计数是由程序猿自己来控制，优秀的程序员能够自如的把控对象之间的持有关系；到了ARC和swift中，由于编译器接手了内存管理的工作，为了方便程序员控制“对象之间的持有关系”，苹果于2011 WWDC Session #322中提出 weak strong dance ,官方示例代码如下 - (void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:_observer];&#125;- (void)loadView&#123; [super loadView]; __weak TestViewController *wself = self; _observer = [[NSNotificationCenter defaultCenter] addObserverForName:@&quot;testKey&quot; object:nil queue:nil usingBlock:^(NSNotification *note) &#123; TestViewController *sself = wself; [sself dismissModalViewControllerAnimated:YES]; &#125;];&#125; 用途在使用block时，因为block会捕获外部变量，并将其拷贝到block中。ARC 下这里的变量如果是指针变量，会将指针变量所指向的对象的引用计数加一。 因此如果不是对block有一定理解很容易发生循环引用，在这篇文章里有介绍会发生循环引用的情景。在RAC及swift中，为了避免block带来的循环引用，官方推荐 weak strong dance ，即 在block外部声明一个弱引用对象，在block内部声明一个局部变量强持有这个弱引用，通过使用新生成局部变量来避免循环引用。 原理说到原理，得从block的内部结构说起：其中invoke指向block的实现代码，variables保存block捕获到的外部变量。 现在来分析引言中的示例代码： block 会将wself捕获到variables中，因为是weak修饰的，因此block不会对self进行强引用；同时 block 中的 invoke (函数指针)会指向 block 中的实现代码。 在执行block时(即调用invoke)，TestViewController *sself = wself; 才会执行,如果执行这行代码时self还未释放，那么这里会将TestViewController实例的引用计数加一，防止在调用self期间self已经被释放。当这个方法执行完，ARC会自动将引用计数减一。 如果在执行block时，self已经释放，即wself被置为nil。那么 TestViewController *sself = wself; 执行时sself得到的也是一个nil，因此 [sself dismissModalViewControllerAnimated:YES]; 将不会被执行。 如果所有时候都和3中一样只是“不执行”，那该有多好。但是结果往往不如人意。不信？ 测试代码如下： ///WeakTestObject.htypedef void(^test_block)(void);@interface WeakTestObject : NSObject@property (copy,nonatomic) test_block block;@end///ViewController.m- (void)viewDidLoad &#123; [super viewDidLoad]; WeakTestObject *obj = [[WeakTestObject alloc]init]; obj.block = ^&#123; NSLog(@&quot;execute block in obj&quot;); &#125;; __weak __typeof(obj) wObj = obj; test_block VcBlock = ^&#123; WeakTestObject *sObj = wObj; sObj.block(); &#125;; obj = nil; VcBlock(); &#125; 当 VcBlock 在执行之前，obj已经释放，导致执行 VcBlock 过程中 sObj 以及 sObj.block 均为nil。程序进而crash在 sObj.block(); 这里。 真实情况往往比这里的模拟代码复杂很多，可能会经过几次时间和空间的跨度；那么如何避免这种crash呢？ 两种处理： 1 、对 sObj.block 进行判断 test_block block = ^&#123; WeakTestObject *sObj = wObj; if (sObj.block) &#123; sObj.block(); &#125; &#125;; 2、 对 sObj 进行判断 test_block block = ^&#123; WeakTestObject *sObj = wObj; if (sObj) &#123; sObj.block(); &#125; &#125;; 显然第二种处理更优。首先我们没有必要对sObj的每一个属性进行判断，其实 在使用sObj 时 ，往往也不是仅仅执行它的一个block属性，而且会涉及到block嵌套或其他各种坑爹情况，其次根据接口封闭原则我们也不应该过多去关心类的实现。 最终 weak strong dance 的正确姿势如下： __weak __typeof(obj) wObj = obj; test_block block = ^&#123; WeakTestObject *sObj = wObj; if (sObj) &#123; /// do ... &#125; &#125;; 扩展1. RAC中的宏 因为RAC中大量使用block语言，为了方便开发者RAC中定义了一对宏 @weakify() @strongify() ，对于这对宏的具体分析可阅读哀殿的 这篇文章 ，文中提到“Xcode 丢失了错误提示的能力”这一问题另外YYKit中也定义了类似的宏，同时避免了上述问题,如下 #ifndef weakify #if DEBUG #if __has_feature(objc_arc) #define weakify(object) autoreleasepool&#123;&#125; __weak __typeof__(object) weak##_##object = object; #else #define weakify(object) autoreleasepool&#123;&#125; __block __typeof__(object) block##_##object = object; #endif #else #if __has_feature(objc_arc) #define weakify(object) try&#123;&#125; @finally&#123;&#125; &#123;&#125; __weak __typeof__(object) weak##_##object = object; #else #define weakify(object) try&#123;&#125; @finally&#123;&#125; &#123;&#125; __block __typeof__(object) block##_##object = object; #endif #endif#endif#ifndef strongify #if DEBUG #if __has_feature(objc_arc) #define strongify(object) autoreleasepool&#123;&#125; __typeof__(object) object = weak##_##object; #else #define strongify(object) autoreleasepool&#123;&#125; __typeof__(object) object = block##_##object; #endif #else #if __has_feature(objc_arc) #define strongify(object) try&#123;&#125; @finally&#123;&#125; __typeof__(object) object = weak##_##object; #else #define strongify(object) try&#123;&#125; @finally&#123;&#125; __typeof__(object) object = block##_##object; #endif #endif#endif 这里补充另一个坑(请注意如下两种调用的区别) //1[self.viewModel.resignSubject subscribeNext:^(id x) &#123; @strongify(self) [self.keyBoard keyboardDown]; &#125;];//2[self.viewModel.resignSubject subscribeNext:^(id x) &#123; @strongify(self) [_keyBoard keyboardDown]; &#125;]; 在 1 中 self.keyBoard 中的self其实是被重定义的局部的“self”, 而我们通过 _keyBoard 调用的话，表面上虽然看起来连self都没有调用，更不会有什么问题了。但，第二种写法其实是存在很大隐患的，系统在“寻找” _keyBoard 这个实例对象时，是通过对 self 指针进行地址偏移得到的，在这里编译器可不会对这个self进行宏替换。 另外在RAC源码中还有对另一个宏 @unsafeify() 的使用 RACCompoundDisposable *selfDisposable = self.disposable; [selfDisposable addDisposable:otherDisposable]; @unsafeify(otherDisposable); // If this subscription terminates, purge its disposable to avoid unbounded // memory growth. [otherDisposable addDisposable:[RACDisposable disposableWithBlock:^&#123; @strongify(otherDisposable); [selfDisposable removeDisposable:otherDisposable]; &#125;]]; @unsafeify() 就是 __unsafe_unretained 在RAC中的宏，但是这种用法即使在RAC源码中出现的都极少，不过 __unsafe_unretained 对比 __weak 来说在性能会比较好。 2. 接口设计原则首先，并不是涉及到block引用外部对象的问题都会带来循环引用；其次，如果是我们自己设计一个类的时候，应该尽量的避免可能产生循环引用的问题(例如执行完block后将其置nil)，如果实在无法避免应该在接口里详细说明。例如：苹果框架中UIView封装的 animateWithDuration 方法、GCD等都不会带来循环引用(注：NSTimer方法可能会带来循环引用); 还有一些有名的三方框架例如 Masonry 也不会产生循环引用。 3. swift 中的 weak strong dancetestFunc(closure:&#123; [weak self] in if let strongSelf = self &#123; // do something print(strongSelf) &#125; &#125;)testFunc(closure:&#123; [weak self] in guard let strongSelf = self else &#123;return&#125; ///do something print(strongSelf) &#125;) 上面是根据可选绑定方式得来的较常规的写法，还有如下这种方式，可避免另外显示生成strongSelf testFunc(closure:&#123; [weak self] in withExtendedLifetime(self, &#123; print(self ?? 0) &#125;) &#125;) 只是经 withExtendedLifetime 处理后的self 变为了一个可选类型。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARC下NSStackBlock去哪了]]></title>
    <url>%2F2017%2F03%2F24%2FARC%E4%B8%8BNSStackBlock%E5%8E%BB%E5%93%AA%E4%BA%86%2F</url>
    <content type="text"><![CDATA[我在 Objective-C中Block的类型 一文中说到MRC下有NSGlobalBlock、NSMallocBlock以及NSStackBlock三种类型的block，而ARC下是没有NSStackBlock类型的，在这里对其进行一个更正补充。 在RAC下，进行如下测试：CGFloat f = 1.1;NSLog(@&quot;%@&quot;, ^&#123;NSLog(@&quot;%lf&quot;,f);&#125;);NSLog(@&quot;%@&quot;,[^&#123;NSLog(@&quot;%lf&quot;,f);&#125; copy]);void(^deliveryBlock)(void) = ^&#123;NSLog(@&quot;%lf&quot;,f);&#125;;NSLog(@&quot;%@&quot;, deliveryBlock); 输出日志为2017-03-24 22:20:22.526 testdemo[48961:588668] &lt;__NSStackBlock__: 0x7fff525a8c20&gt;2017-03-24 22:20:22.526 testdemo[48961:588668] &lt;__NSMallocBlock__: 0x60000005e420&gt;2017-03-24 22:20:22.527 testdemo[48961:588668] &lt;__NSMallocBlock__: 0x60000005e420&gt; 我发现，在直接打印block的时候，他的类型显示的还是NSStackBlock。而我们将这个block进行赋值之后，打印deliveryBlock的结果是NSMallocBlock类型。也就是说，NSStackBlock类型在ARC下是存在，只是在对他进行赋值的时候，编译器将栈区的block拷贝到了堆区（赋值和copy在这里效果相同）。 至于原因- (void)viewDidLoad &#123; [super viewDidLoad]; NSObject *obj = [[NSObject alloc]init]; void(^deliveryBlock)(void) = ^&#123; NSLog(@&quot;%@&quot;,obj); &#125;; [self didBlock:deliveryBlock];&#125;- (void)didBlock:(void(^)(void)) block &#123; NSLog(@&quot;%@&quot;,block); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; block(); &#125;);&#125; 参照上方代码，假如deliveryBlock是NSStackBlock类型，如果我们把deliveryBlock当作方法参数传递到了另外一个方法，那么一旦deliveryBlock不在原来方法的调用栈，而新方法调用deliveryBlock的时机又不得而知，可能在新方法调用的时候deliveryBlock的时候堆区的obj已经被释放。即：ARC下编译器在NSStackBlock类型的block传递过程中进行了自动优化。 为了进一步验证，我做了如下测试- (void)viewDidLoad &#123; [super viewDidLoad]; [self test:^&#123; NSLog(@&quot;%@&quot;,self.object); &#125;];&#125;- (void)test:(void(^)(void))block &#123; NSLog(@&quot;%@&quot;,block); //log: &lt;__NSStackBlock__: 0x7fff5ef49b88&gt;&#125; 当object作为self的属性时，object在整个vc的生命周期存在，故不会有脱离调用栈的问题，所以编译器没有将其自动拷贝到堆。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Block</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RACSignal的子类们]]></title>
    <url>%2F2017%2F03%2F23%2FRACSignal%E7%9A%84%E5%AD%90%E7%B1%BB%E4%BB%AC%2F</url>
    <content type="text"><![CDATA[研究和使用RAC有一段时间了，但一直很懒，不想写任何东西。决定还是写一点东西吧，也算是强迫自己整理一下。计划从最常用的也是RAC的核心(信号) RACSignal 这个类说起，来引出RAC的方方面面：冷热信号实现及转换、RAC中FRP的体现、rac中的类和协议(RACDisposable、RACSubscriber、RACCommand、 RACChannel…)、 对信号的处理和控制(combineLatest、bind…)、ReactiveCocoa的设计思想及结构体系、遇到的一些坑… RACSignal是什么？在RAC中RACSignal是一个工厂类，他通过各个工厂方法生成不同的子类实例。同时他继承基类RACStream(RAC的抽象类，只是定义了处理信号流的方法，子类通过继承来具体实现)。 下面具体讨论RACSignal的几个子类 RACDynamicSignal用法： //1. 创建信号 RACSignal *dynamicSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;send next&quot;]; [subscriber sendCompleted]; return [RACDisposable disposableWithBlock:^&#123; NSLog(@&quot; to release some object because signal had completed or error&quot;); &#125;]; &#125;];//2. 订阅信号 [dynamicSignal subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;]; 上面的代码创建了一个signal， 如果需要dynamicSignal信号工作，我们需要对其订阅；订阅之后subscriber就会将”send next”传递到x中,因此NSLog的打印就是”send next”，如果你使用过RAC一定对此不会陌生。 平时我们所指的signal其实就是RACDynamicSignal（通过createSignal工厂方法创建的一个子类）。还有一些特殊用途的signal，例如RACErrorSignal、RACEmptySignal、RACReturnSignal都是通过工厂方法获得其实例。 下面通过源码逐步解析： 1 . 创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123; // 1、创建RACDynamicSignal实例：signal RACDynamicSignal *signal = [[self alloc] init]; // 2、signal 中保存 传入的didSubscribe 以便后续对其调用 signal-&gt;_didSubscribe = [didSubscribe copy]; //tip: rac在创建不同实例的时候都会调用这个方法，给name属性赋值（RACStream中唯一具体实现的方法），给不同对象不同的标记用于输出日志等 return [signal setNameWithFormat:@&quot;+createSignal:&quot;];&#125; 2. 订阅信号 // subscribeNext方法是对订阅过程的一个封装，便于上层调用- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock &#123; NSCParameterAssert(nextBlock != NULL); //1、创建订阅者，将nextBlock参数再次传递 RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL]; //2、传入订阅者，进行订阅 return [self subscribe:o];&#125; 2.1创建订阅者 // 这里是对订阅者的初步创建，后面还有对它的二次处理 + (instancetype)subscriberWithNext:(void (^)(id x))next error:(void (^)(NSError *error))error completed:(void (^)(void))completed &#123; //1、创建RACSubscriber实例：subscriber RACSubscriber *subscriber = [[self alloc] init]; //2、分别记录传入的next、error、completed subscriber-&gt;_next = [next copy]; subscriber-&gt;_error = [error copy]; subscriber-&gt;_completed = [completed copy]; return subscriber;&#125; 2.2订阅 - (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123; NSCParameterAssert(subscriber != nil); RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable]; /* * subscriber 被赋给了一个新的RACPassthroughSubscriber实例 * 并将原来的subscriber以及signal本身和disposable作为新的subscriber的实例对象保存 */ subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable]; if (self.didSubscribe != NULL) &#123; //下列方法会执行传入的bock参数（因涉及到RACDisposable和RACScheduler两大块，不便具体解释过程，可以自己看源码） RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123; // 这里对《1.创建信号》中保存的didSubscribe进行调用，并将subscriber作为block参数传入 RACDisposable *innerDisposable = self.didSubscribe(subscriber); [disposable addDisposable:innerDisposable]; &#125;]; [disposable addDisposable:schedulingDisposable]; &#125; return disposable;&#125; 思路整理：首先createSignal方法创建了一个信号dynamicSignal，并把传入的block参数记录在了dynamicSignal的didSubscribe中；然后subscribeNext方法中创建了一个订阅者 o 用其属性next保存了从subscribeNext方法传入的block，接下来subscribeNext中调用subscribe方法并将 o 作为参数传入；而在subscribe方法中执行了 self.didSubscribe(subscriber) 其中subscriber就是传入subscribe方法的o。也就是执行了一开始保存在dynamicSignal中的didSubscribe。也就是执行了createSignal方法中传入的block ^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;send next&quot;]; [subscriber sendCompleted]; return [RACDisposable disposableWithBlock:^&#123; NSLog(@&quot; to release some object because signal had completed or error&quot;); &#125;];&#125; 终于到了最后一步，我们只需要弄清[subscriber sendNext:@&quot;send next&quot;];这一方法的具体实现，整个RACDynamicSignal的工作原理就全部揭晓。（sendCompleted 以及 RACDisposable 相关计划下次介绍）sendNext的实现如下： - (void)sendNext:(id)value &#123; @synchronized (self) &#123; void (^nextBlock)(id) = [self.next copy]; if (nextBlock == nil) return; nextBlock(value); &#125;&#125; 可以看到这里其实就是对上文保存在 o 中的 next 进行执行，同时将传入的 value 再次当作 next 的参数传入。也就是执行了订阅信号方法subscribeNext 时传入的 block ，如下 ^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125; 直到这里，整个信号的 “创建-发送-订阅” 的过程全部分析完毕。这里强调一下：RACDynamicSignal 中的信号需要被订阅，然后信号才会被激活。 RACSubjectRACSubject 是 RACSignal 的一个子类，用法如下： //1、创建实例RACSubject *subject = [RACSubject subject];//2、订阅信号[subject subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x);&#125;];//3、发送信号[subject sendNext:@&quot;send next&quot;]; 和RACSignal不同的是 RACSubject 是先订阅信号，再发送信号。RACSignal是冷信号，而RACSubject及其子类是热信号，这也是为什么RACSubject的创建不是通过RACSignal的工厂方法而是单独拿出来做为一个体系的原因。下面通过源码具体分析： 1 . 创建信号 //仅仅只是实例了一个对象+ (instancetype)subject &#123; return [[self alloc] init];&#125; 2. 订阅信号 //执行的还是其父类RACSignal中的方法- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock &#123; NSCParameterAssert(nextBlock != NULL); RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL]; return [self subscribe:o];&#125; 2.1 创建订阅者 // 这里和RACSignal中也是一样，执行的RACSubscriber中的方法+ (instancetype)subscriberWithNext:(void (^)(id x))next error:(void (^)(NSError *error))error completed:(void (^)(void))completed &#123; RACSubscriber *subscriber = [[self alloc] init]; subscriber-&gt;_next = [next copy]; subscriber-&gt;_error = [error copy]; subscriber-&gt;_completed = [completed copy]; return subscriber;&#125; 2.2 订阅 // 这里开始不同，RACSubject对其进行了重写。其实这个方法，在RACSignal中没有实现，RACDynamicSignal也是执行的RACDynamicSignal中重写的方法- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123; NSCParameterAssert(subscriber != nil); RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable]; subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable]; // 这里和RACDynamicSignal中不同，RACSubject持有一个数组subscribers，来储存所有的订阅者，对subject的每一次订阅都会将订阅者加入该数组保存起来 NSMutableArray *subscribers = self.subscribers; @synchronized (subscribers) &#123; [subscribers addObject:subscriber]; &#125; return [RACDisposable disposableWithBlock:^&#123; @synchronized (subscribers) &#123; // Since newer subscribers are generally shorter-lived, search // starting from the end of the list. NSUInteger index = [subscribers indexOfObjectWithOptions:NSEnumerationReverse passingTest:^ BOOL (id&lt;RACSubscriber&gt; obj, NSUInteger index, BOOL *stop) &#123; return obj == subscriber; &#125;]; if (index != NSNotFound) [subscribers removeObjectAtIndex:index]; &#125; &#125;];&#125; 3. 发送信号 // 循环遍历subscribers数组，逐个执行:[subscriber sendNext:value]- (void)sendNext:(id)value &#123; [self enumerateSubscribersUsingBlock:^(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:value]; &#125;];&#125;- (void)enumerateSubscribersUsingBlock:(void (^)(id&lt;RACSubscriber&gt; subscriber))block &#123; NSArray *subscribers; @synchronized (self.subscribers) &#123; subscribers = [self.subscribers copy]; &#125; for (id&lt;RACSubscriber&gt; subscriber in subscribers) &#123; block(subscriber); &#125;&#125; 和RACSignal不同的是：RACSubject 通过subscribeNext方法将订阅者保存在subscribers数组中，供sendNext方法调用；而RACSignal是先保存一个didSubscribe对象，然后通过subscribeNext方法创建一个订阅者subscriber作为参数传入didSubscribe中，进而subscriber才能发送信号。简言之：RACSubject会保存所有subscriber（状态），sendNext只是对其操作。RACSignal 在被订阅后才会生成subscriber，并立即对其操作。这也是冷信号和热信号的区别（冷信号需要通过订阅来激活） RACReplaySubjectRACReplaySubject 是 RACSubject 的一个子类，他们都是热信号，那么他们有什么不同呢，还是从源码入手 //1、创建实例 RACReplaySubject *subject = [RACReplaySubject replaySubjectWithCapacity:2]; //2、订阅信号 [subject subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;]; //3、发送信号 [subject sendNext:@&quot;send next&quot;]; 1 . 创建信号 + (instancetype)replaySubjectWithCapacity:(NSUInteger)capacity &#123; return [(RACReplaySubject *)[self alloc] initWithCapacity:capacity];&#125;- (instancetype)initWithCapacity:(NSUInteger)capacity &#123; self = [super init]; if (self == nil) return nil; // 这里会用一个属性capacity 将 传入的数记录下来，下面会有这个数的用途 _capacity = capacity; _valuesReceived = (capacity == RACReplaySubjectUnlimitedCapacity ? [NSMutableArray array] : [NSMutableArray arrayWithCapacity:capacity]); return self;&#125;// 也可以直接对其实例，capacity为最大无符号整数- (instancetype)init &#123; // const NSUInteger RACReplaySubjectUnlimitedCapacity = NSUIntegerMax; return [self initWithCapacity:RACReplaySubjectUnlimitedCapacity];&#125; 2. 订阅信号 // 也是在subscribe方法发生变化，走的是RACReplaySubject中的方法- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123; RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable]; RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123; @synchronized (self) &#123; // 这里会从valuesReceived里sendNext未被执行过value，第三步中会有 valuesReceived 的操作 for (id value in self.valuesReceived) &#123; if (compoundDisposable.disposed) return; [subscriber sendNext:(value == RACTupleNil.tupleNil ? nil : value)]; &#125; if (compoundDisposable.disposed) return; if (self.hasCompleted) &#123; [subscriber sendCompleted]; &#125; else if (self.hasError) &#123; [subscriber sendError:self.error]; &#125; else &#123; RACDisposable *subscriptionDisposable = [super subscribe:subscriber]; [compoundDisposable addDisposable:subscriptionDisposable]; &#125; &#125; &#125;]; [compoundDisposable addDisposable:schedulingDisposable]; return compoundDisposable;&#125; 3. 发送信号 - (void)sendNext:(id)value &#123; @synchronized (self) &#123; // 每次将发送过的value添加到valuesReceived中记录下来 [self.valuesReceived addObject:value ?: RACTupleNil.tupleNil]; // 调用父类也就是RACSubject的sendNext [super sendNext:value]; // 通过初始化时的capacity值截取valuesReceived的元素(从数组头部开始，也就是最先添加进来的value) if (self.capacity != RACReplaySubjectUnlimitedCapacity &amp;&amp; self.valuesReceived.count &gt; self.capacity) &#123; [self.valuesReceived removeObjectsInRange:NSMakeRange(0, self.valuesReceived.count - self.capacity)]; &#125; &#125;&#125; 为了解释发生了什么，进行如下测试 RACReplaySubject *subject = [RACReplaySubject subject];[subject subscribeNext:^(id x) &#123; NSLog(@&quot;%@--1&quot;,x);&#125;];[subject subscribeNext:^(id x) &#123; NSLog(@&quot;%@--2&quot;,x);&#125;];[subject sendNext:@&quot;send next1&quot;];[subject sendNext:@&quot;send next2&quot;];[subject subscribeNext:^(id x) &#123; NSLog(@&quot;%@--3&quot;,x);&#125;]; 日志： //12017-03-23 22:03:03.722 testdemo[3509:143199] send next1--1//22017-03-23 22:03:03.722 testdemo[3509:143199] send next1--2//32017-03-23 22:03:03.722 testdemo[3509:143199] send next2--1//42017-03-23 22:03:03.723 testdemo[3509:143199] send next2--2//52017-03-23 22:03:03.723 testdemo[3509:143199] send next1--3//62017-03-23 22:03:03.723 testdemo[3509:143199] send next2--3 分析: [subject sendNext:@”send next1”] 毫无疑问会打印 1 2 两条日志，同时将value存入了valuesReceived； [subject sendNext:@”send next2”] 会打印 3 4 两条日志，也同时将value存入了valuesReceived，到此valuesReceived里就存有两个value了； 对subject 进行第三次 subscribeNext 时，因为valuesReceived里是有值的，所以会执行两次subscriber sendNext,也就是打印出日志 5 和 6 。 RACReplaySubject 会将每次sendNext的值记录到valuesReceived（根据capacity大小会移除最先添加的元素），之后对RACReplaySubject的订阅会将valuesReceived里的记录通过订阅者来发送。 这也就是RACReplaySubject的区别 对于RACSignal的介绍到此结束，我们可以发现对RACDynamicSignal的每次订阅都会重复执行didSubscribe，而RACSubject则不会。 在我们平时使用时，很多场景是需要用到 RACDynamicSignal 的。例如：我们会把数据处理、网络请求、UI刷新等等一系列操作放在didSubscribe里（这也是RAC的宗旨啊，将平时的各种操作都转化为炫酷的信号的形式，优雅的进行传递与交互）。但是我们不希望每次对RACSignal的订阅都重复执行didSubscribe，因为这样会带来bug或者性能问题。 这时，我们要做的就是将冷信号转换为热信号，因为热信号的重复订阅是不会带来这个问题的。那么如何将冷信号转化为热信号呢，后面再说吧。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>RAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由Swift柯里化说开到block的循环引用]]></title>
    <url>%2F2017%2F03%2F08%2F%E7%94%B1Swift%E6%9F%AF%E9%87%8C%E5%8C%96%E8%AF%B4%E5%BC%80%E5%88%B0block%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[柯里化是函数式编程中的一个概念, 大致意图就是将一个含有多个参数的方法改为调用原方法首个参数并将调用余下参数的方法作为返回值的方法。 Swift中的柯里化Swift2.2中的写法如下//加法函数，需要同时传入两个参数func add(num1:Int, _ num2:Int) -&gt; Int &#123; return num1 + num2&#125; add(1,2) //柯里化写法func add(num1:Int)(_ num2:Int) -&gt; Int &#123; return num1 + num2&#125;let oneAdd = add(1)oneAdd(2) Swift3中，这种显式写法已被移除。但是底层实现还在，毕竟这种用法略微鸡肋。我们仍可以通过返回一个闭包来实现柯里化，如下：func add(_ num1:Int) -&gt; (Int) -&gt; Int &#123; return &#123; num1 + $0 &#125;&#125;let oneAdd = add(1)oneAdd(2) 关于闭包为什么要介绍柯里化？在Swift中，属性调用实例方法时, 属性其实也是作为方法参数的 例如：struct testStruct &#123; func testMethod(str:String) &#123; print(&quot;\(str)&quot;) &#125;&#125;let ts = testStruct()//属性调用ts.testMethod(str: &quot;12&quot;)//柯里化调用testStruct.testMethod(ts)(str: &quot;12&quot;) 这种用法的深层含义其实是：对象并不会持有他的实例方法。因此当我们把闭包作为参数的时候，对象在调用实力方法时是可以直接在闭包参数中使用对象本身的，并不会产生循环引用。除非：class testClass1 &#123; var handler:(() -&gt;())? func testMethod(handler:@escaping ()-&gt;()) &#123; self.handler = handler &#125; func printTs() &#123; self.handler!() &#125;&#125;var tc = testClass1()tc.testMethod &#123; print(&quot;\(tc)&quot;)&#125;tc.printTs() 由此联想到OC，故有此篇这种情况下,控制器是可以正常释放的：- (void)viewDidLoad &#123; [super viewDidLoad]; [self testBlock:^&#123; NSLog(@&quot;%@&quot;,self.view); &#125;];&#125;- (void)testBlock:(void(^)(void))block &#123; block();&#125; 原因同样是，实例对象不持有实例方法(runtime层:实例方法在类的method_list中，类方法则是元类持有) 当testBlock方法中用一个block属性强引用block参数，则会产生循环引用,如下:- (void)viewDidLoad &#123; [super viewDidLoad]; [self testBlock:^&#123; NSLog(@&quot;%@&quot;,self.view); &#125;];&#125;- (void)testBlock:(void(^)(void))block &#123; self.block = block;&#125; 循环引用其实很好理解，但凡对象之间互相强引用形成了一个强引用的引用环就会产生循环引用，一旦这个环的某一节被置为nil或者声明为weak，则不会有循环引用。 这里再提一下，我们平时在写网络请求时，一般会这么写：__weak typeof(self) ws = self;//注：sendRequestCallBack的实现中只是执行block，没有强引用block[[Request shareRequest]sendRequestCallBack:^(NSDictionary *callDic)&#123; ws.callDic = callDic; // 处理业务逻辑...&#125;]; 很多人都习惯性的用弱引用,其实是没有必要的，并不会产生循环引用。 设想一下这个场景：我们push到一个页面后发出了请求，在请求还没有回调的时候pop出界面。 如果这里，用的弱引用，控制器会被释放，上文block中的操作是不会被执行的 如果这里，用的强引用，在这个方法还没被执行完的时候，block会一直持有控制器，知道方法结束，那么当请求完成上文block中的操作是会被执行的，随后控制器才会释放 所以 我们应该根据业务需求来判断是否使用弱引用，当回调中是处理页面逻辑一般是没必要继续执行的，如果是本地化存储或者一些其他有必要的操作，是需要执行回调的。当然，出于性能考虑，最好的做法是当控制器pop之后根据业务需要来判断是否终止网络请求或者做其它处理，本篇不再对此详细分析…]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些C标准中对debug有帮助的宏]]></title>
    <url>%2F2017%2F02%2F16%2F%E9%82%A3%E4%BA%9BC%E6%A0%87%E5%87%86%E4%B8%AD%E5%AF%B9debug%E6%9C%89%E5%B8%AE%E5%8A%A9%E7%9A%84%E5%AE%8F%2F</url>
    <content type="text"><![CDATA[最近在重构消息模块，研究云信官方demo的时候发现他们用 CocoaLumberjack 这个三方框架来监控日志输出，我之前也有在自己的项目中引入 NSSLogger 来达到类似的目的。 ps: 我们项目中一直存在一坨宏，也不知道谁加上去的2333 #ifdef DEBUG#define DLog( s, ... ) NSLog( @&quot;&lt;%p %@:(%d)&gt; %@&quot;, self, [[NSString stringWithUTF8String:__FILE__] lastPathComponent], __LINE__, [NSString stringWithFormat:(s), ##__VA_ARGS__] )#define ALog(fmt, ...) NSLog((@&quot;%s [Line %d] &quot; fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__);#else#define DLog( s, ... )#define ALog(...)#endif 今天特地整理一下这些debug的时候常用的宏 打印函数的宏__func__、__FUNCTION__、__PRETTY_FUNCTION__测试代码段如下： NSLog(@&quot;__func__:%s,&quot;,__func__);NSLog(@&quot;__FUNCTION__:%s,&quot;,__FUNCTION__); NSLog(@&quot;__PRETTY_FUNCTION__:%s,&quot;,__PRETTY_FUNCTION__); 在oc的方法中他们的表现是一样的，输出如下： 2017-02-16 15:30:31.474 testdemo[74077:387792] __func__:-[testViewController test],2017-02-16 15:30:31.474 testdemo[74077:387792] __FUNCTION__:-[testViewController test],2017-02-16 15:30:31.475 testdemo[74077:387792] __PRETTY_FUNCTION__:-[testViewController test], 在main函数中(也就是函数作为程序的一级成员时)，输出如下： 2017-02-16 16:34:36.234 testdemo[82693:425275] __func__:main,2017-02-16 16:34:36.234 testdemo[82693:425275] __FUNCTION__:main,2017-02-16 16:34:36.235 testdemo[82693:425275] __PRETTY_FUNCTION__:int main(int, char **), 其中 __PRETTY_FUNCTION__ 会输出 当前所在函数名，包括返回类型和参数类型，而在有一些IDE环境中是不支持 __func__ 的。 打印时间的宏__TIME__、 __DATE__测试代码段如下： NSLog(@&quot;__TIME__:%s,&quot;,__TIME__);NSLog(@&quot;__DATE__:%s,&quot;,__DATE__); __TIME__ 会输出当前源文件编译的日期，__DATE__ 会输出进行预处理的日期，输出如下: 2017-02-16 16:43:03.170 testdemo[82693:425275] __TIME__:15:30:13,2017-02-16 16:43:03.171 testdemo[82693:425275] __DATE__:Feb 16 2017, 打印代码信息相关的宏 __LINE__、__FILE__其中 __LINE__ 会输出源文件中当前代码所在行号，__FILE__ 会输出当前源文件本地所在的绝对路径测试结果如下： //测试代码片段51 NSLog(@&quot;__LINE__:%d,&quot;,__LINE__);52 NSLog(@&quot;__FILE__:%s,&quot;,__FILE__);//控制台输出2017-02-16 16:43:03.170 testdemo[82693:425275] __LINE__:51,2017-02-16 16:43:03.170 testdemo[82693:425275] __FILE__:/Users/hanling/Desktop/testdemo/testdemo/testViewController.m, 输出可变参数的宏__VA_ARGS__(C99提供的可变宏)，在上文DLog中也有用到过。它是可变参数宏，对他进行宏定义可以传入不定个数的参数，在他前面加上 ## 则表示可变参数被忽略或为空时会直接将其带来的负面效果移除，就像 __VA_ARGS__ 完全没有存在一样。举个例子： #define DLog( s, ... ) NSLog( @&quot;&lt;%p %@:(%d)&gt; %@&quot;, self, [[NSString stringWithUTF8String:__FILE__] lastPathComponent], __LINE__, [NSString stringWithFormat:(s), ##__VA_ARGS__] ) 这个宏在 DLog( s, ... ) 中传入的可变参数个数为0时，##__VA_ARGS__ 前的逗号不会被输出 第二种可变参数的宏定义方法(GCC提供的可变宏) #define cprint(format,args...) NSLog(format, ##args) 在 Xcode 中这两种方式都是支持的 另外：在OC中我们还可以这么玩(来自喵神的博客) //输出当前方法NSLog(@&quot;Current selector: %@&quot;,NSStringFromSelector(_cmd));//输出当前类NSLog(@&quot;Object class: %@&quot;,NSStringFromClass(self.class));//输出当前源文件名NSLog(@&quot;Filename: %@&quot;,[[NSString stringWithUTF8String:__FILE__] lastPathComponent]); tip 如果有需要你还可以利用OC的反射机制打印更多东西]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git之用命令新建本地以及远程仓库]]></title>
    <url>%2F2016%2F12%2F21%2Fgit%E4%B9%8B%E7%94%A8%E5%91%BD%E4%BB%A4%E6%96%B0%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%A5%E5%8F%8A%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[基本篇创建本地仓库 创建文件: mkdir testcd testtouch README.md 初始化git: git init 提交到本地仓库: git add .git commit -m &quot;commit message&quot; 本地仓库发布到远程 新建远程仓库: curl -u &apos;username&apos; https://api.github.com/user/repos -d &apos;&#123;&quot;name&quot;:&quot;test&quot;&#125;&apos; 关联远程仓库(origin是git提供的仓库默认名，可自定义): git remote add origin gitAddress/RepoName push到远程仓库: git push origin master zsh篇探索过程： 在oh-my-zsh的plugins下搜索git，找到几个可疑目录 逐个目录一一探究、发现是github目录。github下的github.plugin.zsh如下： 我在这个文件里发现empty_gh new_gh exist_gh git.io 这几个方法，方法用途查看源码和注释一目了然，不再赘述。 接下来在 .zshrc 中的 plugins 里加入 github ，如下: :wq之后执行 source .zshrc基本篇的创建只需 empty_gh test 即可完成 而新建远程仓库我直接在 github.plugin.zsh 里加了一个方法: new_repo,如下:]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSLogger的使用]]></title>
    <url>%2F2016%2F12%2F14%2FNSLogger%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[用途用来监控app的日志,从此摆脱xcode的控制台,mac版界面如下: 使用步骤:安装 NSLogger Viewer MAC端 当我安装NSLogger Viewer之后发现它监听到了macQQ的日志,看来macQQ也有使用NSLogger 在项目中加入NSLogger框架在podFile中添加pod &#39;NSLogger&#39;之后执行 pod install ;或者手动拖入到项目 在项目中使用在必要的地方添加#import &quot;NSLogger.h&quot;头文件即可 我的一些处理(供参考) 添加一个宏，自由切换xcode控制台和NSLogger // 使用NSLogger打印:取消注释下一行;使用xcode控制台:注释下一行//#define NSLOGGER_CLIENT 导入NSLogger.h时进行判断 #ifdef NSLOGGER_CLIENT #import &quot;NSLogger.h&quot; //使用NSLogger#else #ifdef DEBUG #define LoggerError(level,...) NSLog(__VA_ARGS__) #define LoggerApp(level, ...) NSLog(__VA_ARGS__) #define LoggerView(level,...) NSLog(__VA_ARGS__) #define LoggerService(level,...) NSLog(__VA_ARGS__) #define LoggerModel(level,...) NSLog(__VA_ARGS__) #define LoggerData(level,...) NSLog(__VA_ARGS__) #define LoggerNetwork(level,...) NSLog(__VA_ARGS__) #define LoggerLocation(level,...) NSLog(__VA_ARGS__) #define LoggerPush(level,...) NSLog(__VA_ARGS__) #define LoggerFile(level,...) NSLog(__VA_ARGS__) #define LoggerSharing(level,...) NSLog(__VA_ARGS__) #define LoggerAd(level,...) NSLog(__VA_ARGS__) #else #define NSLog(...) while(0) &#123;&#125; #define LoggerError(...) while(0) &#123;&#125; #define LoggerApp(level, ...) while(0) &#123;&#125; #define LoggerView(...) while(0) &#123;&#125; #define LoggerService(...) while(0) &#123;&#125; #define LoggerModel(...) while(0) &#123;&#125; #define LoggerData(...) while(0) &#123;&#125; #define LoggerNetwork(...) while(0) &#123;&#125; #define LoggerLocation(...) while(0) &#123;&#125; #define LoggerPush(...) while(0) &#123;&#125; #define LoggerFile(...) while(0) &#123;&#125; #define LoggerSharing(...) while(0) &#123;&#125; #define LoggerAd(...) while(0) &#123;&#125; #endif#endif 原理在NSLogger.h文件中定义了如下宏 #define NSLog(...) LogMessageF(__FILE__, __LINE__, __FUNCTION__, @&quot;NSLog&quot;, 0, __VA_ARGS__) #define LoggerError(level, ...) LogMessageF(__FILE__, __LINE__, __FUNCTION__, @&quot;Error&quot;, level, __VA_ARGS__) #define LoggerApp(level, ...) LogMessageF(__FILE__, __LINE__, __FUNCTION__, @&quot;App&quot;, level, __VA_ARGS__) #define LoggerView(level, ...) LogMessageF(__FILE__, __LINE__, __FUNCTION__, @&quot;View&quot;, level, __VA_ARGS__) #define LoggerService(level, ...) LogMessageF(__FILE__, __LINE__, __FUNCTION__, @&quot;Service&quot;, level, __VA_ARGS__) #define LoggerModel(level, ...) LogMessageF(__FILE__, __LINE__, __FUNCTION__, @&quot;Model&quot;, level, __VA_ARGS__) #define LoggerData(level, ...) LogMessageF(__FILE__, __LINE__, __FUNCTION__, @&quot;Data&quot;, level, __VA_ARGS__) #define LoggerNetwork(level, ...) LogMessageF(__FILE__, __LINE__, __FUNCTION__, @&quot;Network&quot;, level, __VA_ARGS__) #define LoggerLocation(level, ...) LogMessageF(__FILE__, __LINE__, __FUNCTION__, @&quot;Location&quot;, level, __VA_ARGS__) #define LoggerPush(level, ...) LogMessageF(__FILE__, __LINE__, __FUNCTION__, @&quot;Push&quot;, level, __VA_ARGS__) #define LoggerFile(level, ...) LogMessageF(__FILE__, __LINE__, __FUNCTION__, @&quot;File&quot;, level, __VA_ARGS__) #define LoggerSharing(level, ...) LogMessageF(__FILE__, __LINE__, __FUNCTION__, @&quot;Sharing&quot;, level, __VA_ARGS__) #define LoggerAd(level, ...) LogMessageF(__FILE__, __LINE__, __FUNCTION__, @&quot;Ad and Stat&quot;, level, __VA_ARGS__) 其中 #define NSLog(...) LogMessageF(__FILE__, __LINE__, __FUNCTION__, @&quot;NSLog&quot;, 0, __VA_ARGS__) 这里直接将所有的NSLog替换为了LogMessageF然后查看LogMessageF的实现 void LogMessageF(const char *filename, int lineNumber, const char *functionName, NSString *domain, int level, NSString *format, ...)&#123; va_list args; va_start(args, format); LogMessageTo_internal(NULL, filename, lineNumber, functionName, domain, level, format, args); va_end(args);&#125; 其中LogMessageTo_internal(NULL, filename, lineNumber, functionName, domain, level, format, args); 就是向网络发送数据 同时NSLogger.h文件中还定义了很多其他的宏，根据命名大概就可以猜到他们的用途吧ps: 更多功能有待大家去探索，不想写2333~ 附一段网络请求单例方法代码(请忽略里面一大串恶心的东西，只是想说明一下NSLogger的使用): -(void)sendRequest:(NSMutableDictionary *)mutableDic url:(NSString *)url progress:( void (^)(NSProgress *uploadProgress))uploadProgressBack compelete:(void(^)(BOOL success, NSDictionary *responseObject))compelete &#123; if (manager == nil) &#123; manager = [AFHTTPSessionManager manager]; &#125; manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@&quot;text/html&quot;,@&quot;text/plain&quot;,@&quot;application/json&quot;,nil]; [manager.requestSerializer setValue:@&quot;ture&quot; forHTTPHeaderField:@&quot;ifmodified&quot;]; [manager.requestSerializer setValue:@&quot;ios&quot; forHTTPHeaderField:@&quot;app&quot;]; NSMutableDictionary *paramDic = nil; if(mutableDic) &#123; paramDic = [[NSMutableDictionary alloc] initWithDictionary:mutableDic]; &#125; else &#123; paramDic = [[NSMutableDictionary alloc] init]; &#125; [paramDic setValue:[[JFUserInfo shareUserInfo] getToken] forKey:kUSERTOKE]; [paramDic setValue:[NSString appVersion] forKey:kCLIENTVERSION]; //使用NSLogger LoggerService(2,@&quot;%@&quot;,url); LoggerData(2,@&quot;paramDic = %@&quot;, paramDic); [manager POST:url parameters:paramDic progress:^(NSProgress * _Nonnull uploadProgress) &#123; if (uploadProgressBack) &#123; uploadProgressBack(uploadProgress); &#125; &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; //使用NSLogger LoggerData(3,@&quot;responseObject = %@&quot;, responseObject); NSLog(@&quot;errmsg：%@&quot;,(NSDictionary *)responseObject[@&quot;errmsg&quot;]); NSDictionary *responseDic = (NSDictionary *)responseObject; NSNumber *code = responseDic[@&quot;errcode&quot;]; if ([code integerValue] == 2000001 || [code integerValue] == -4) &#123;//重新登录 NSLog(@&quot;错误请求：%@&quot;,responseDic[@&quot;errmsg&quot;]); [[AppDelegate sharedAppDelegate] enterLoginUI]; return; &#125; if (compelete) &#123; if ([code integerValue] == 0) &#123; compelete(YES, responseDic); &#125;else if ([code integerValue] &lt; 0)&#123;// NSLog(@&quot;%@,%@错误请求：%@&quot;,mutableDic,url,responseDic[@&quot;errmsg&quot;]); NSMutableDictionary * dic = [NSMutableDictionary dictionary]; [dic setValue:JFERRORMSG forKey:@&quot;errmsg&quot;]; [dic setValue:[NSNumber numberWithInt:-1] forKey:@&quot;errcode&quot;]; compelete(NO, dic); &#125;else&#123; compelete(NO, responseDic); &#125; &#125; &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;// if (compelete) &#123; NSMutableDictionary * dic = [NSMutableDictionary dictionary]; [dic setValue:JFERRORMSG forKey:@&quot;errmsg&quot;]; [dic setValue:[NSNumber numberWithInt:-1] forKey:@&quot;errcode&quot;]; compelete(NO, dic);// &#125; &#125;];&#125;]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Objective-C中Block的类型]]></title>
    <url>%2F2016%2F12%2F06%2FObjective-C%E4%B8%ADBlock%E7%9A%84%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[在研究block的类型之前，首先我们要知道c类语言的程序编译后在内存中的分布(由高位向低位排序): 栈区:局部变量 堆区:由”alloc”开辟的空间就是在堆区 静态区(全局区): 静态变量、 全局变量（注:未初始化的在bss） 常量区: 常量 代码区: 二进制代码段 这里我们将MRC和ARC分开讨论： 在MRC下有三种类型的blockNSGlobalBlock: 位于内存全局区、不调用外部变量或者仅调用静态区常量区的”变量”CGFloat gFloat = 1.2;NSString *gStr = @&quot;全局字符串&quot;;@implementation test -(void)globalTest &#123; //注:在本例中NSSting分别在内存中的哪个区域呢？ //1、不调用外部变量的block void(^gblock1)(NSString *) = ^(NSString *str)&#123; NSLog(@&quot;%@&quot;,str); &#125;; NSLog(@&quot;%@&quot;,gblock1); gblock1(@&quot;传入字符串常量&quot;); //2、仅调用全局变量的block void(^gblock2)(void) = ^&#123; NSLog(@&quot;%lf&quot;,gFloat); &#125;; NSLog(@&quot;%@&quot;,gblock2); gblock2(); void(^gblock3)(void) = ^&#123; NSLog(@&quot;%@&quot;,gStr); &#125;; NSLog(@&quot;%@&quot;,gblock3); gblock3(); //3、仅调用静态变量的block static CGFloat sFloat = 2.1; void(^gblock4)(void) = ^&#123; NSLog(@&quot;%lf&quot;,sFloat); &#125;; NSLog(@&quot;%@&quot;,gblock4); gblock4(); static NSString *staStr = @&quot;静态字符串&quot;; void(^gblock5)(void) = ^&#123; NSLog(@&quot;%@&quot;,staStr); &#125;; NSLog(@&quot;%@&quot;,gblock5); gblock5();&#125; 控制台输出:2016-12-06 14:50:22.928972 test_demo[18845:866060] &lt;__NSGlobalBlock__: 0x100001050&gt;2016-12-06 14:50:22.929176 test_demo[18845:866060] 传入字符串常量2016-12-06 14:50:22.929221 test_demo[18845:866060] &lt;__NSGlobalBlock__: 0x100001090&gt;2016-12-06 14:50:22.929246 test_demo[18845:866060] 1.2000002016-12-06 14:50:22.929268 test_demo[18845:866060] &lt;__NSGlobalBlock__: 0x1000010d0&gt;2016-12-06 14:50:22.929288 test_demo[18845:866060] 全局字符串2016-12-06 14:50:22.929307 test_demo[18845:866060] &lt;__NSGlobalBlock__: 0x100001110&gt;2016-12-06 14:50:22.929320 test_demo[18845:866060] 2.1000002016-12-06 14:50:22.929338 test_demo[18845:866060] &lt;__NSGlobalBlock__: 0x100001150&gt;2016-12-06 14:50:22.929354 test_demo[18845:866060] 静态字符串 NSStackBlock: 位于内存栈区、仅调用栈区变量-(void)stackTest &#123; //局部变量 CGFloat sFloat = 1.1; void(^sBlock1)(void) = ^&#123; NSLog(@&quot;%lf&quot;,sFloat); &#125;; NSLog(@&quot;%@&quot;,sBlock1); sBlock1();&#125; 控制台输出:2016-12-06 15:04:04.606908 test_demo[18880:873406] &lt;__NSStackBlock__: 0x7fff5fbff6d8&gt;2016-12-06 15:04:04.607076 test_demo[18880:873406] 1.100000 NSMallocBlock: 位于内存堆区、由栈区copy到堆区 -(void)mallocTest &#123; //局部变量 CGFloat sFloat = 1.1;&lt;/br&gt; void(^sBlock1)(void) = ^&#123;&lt;/br&gt; NSLog(@&quot;%lf&quot;,sFloat); &#125;; // NSLog(@&quot;%@&quot;,sBlock1);// sBlock1();&lt;/br&gt; void(^mBlock1)(void) = [sBlock1 copy]; NSLog(@&quot;%@&quot;,mBlock1);&lt;/br&gt; //@property(copy,nonatomic)void(^mBlock2)(void); self.mBlock2 = sBlock1; NSLog(@&quot;%@&quot;,self.mBlock2);&#125; 控制台输出:2016-12-06 15:37:07.306385 test_demo[28582:914325] &lt;__NSMallocBlock__: 0x100402f00&gt;2016-12-06 15:37:07.306699 test_demo[28582:914325] &lt;__NSMallocBlock__: 0x100600000&gt; 在ARC下，仅存在 NSGlobalBlock 、NSMallocBlock 两种block我们切换到arc环境，并且将 mallocTest 中的如下代码注释取消// NSLog(@&quot;%@&quot;,sBlock1);// sBlock1(); 运行得到输出结果：2016-12-06 15:52:42.884091 test_demo[35541:942156] &lt;__NSMallocBlock__: 0x100502eb0&gt;2016-12-06 15:52:42.884379 test_demo[35541:942156] 1.1000002016-12-06 15:52:42.884416 test_demo[35541:942156] &lt;__NSMallocBlock__: 0x100502eb0&gt;2016-12-06 15:52:42.884446 test_demo[35541:942156] &lt;__NSMallocBlock__: 0x100502eb0&gt; 由此可以判断，在arc下没有 NSStackBlock 类型变量、并且 copy 操作只是对堆区 block 进行了一次引用，既然如此我接着对 NSGlobalBlock 、NSMallocBlock 进行copy操作：static NSString *staStr = @&quot;静态字符串&quot;;void(^gblock5)(void) = ^&#123; NSLog(@&quot;%@&quot;,staStr);&#125;;NSLog(@&quot;%@&quot;,gblock5);gblock5();void(^copyBlock)(void) = [gblock5 copy];NSLog(@&quot;%@&quot;,copyBlock); 控制台输出:2016-12-06 16:24:36.832399 test_demo[35671:957646] &lt;__NSGlobalBlock__: 0x100002170&gt;2016-12-06 16:24:36.832415 test_demo[35671:957646] 静态字符串2016-12-06 16:24:36.832438 test_demo[35671:957646] &lt;__NSGlobalBlock__: 0x100002170&gt; void(^mBlock1)(void) = [sBlock1 copy];NSLog(@&quot;%@&quot;,mBlock1);void(^copyBlock)(void) = [mBlock1 copy];NSLog(@&quot;%@&quot;,copyBlock); 控制台输出:2016-12-06 16:27:10.688490 test_demo[35702:959578] &lt;__NSMallocBlock__: 0x1006000c0&gt;2016-12-06 16:27:10.688571 test_demo[35702:959578] &lt;__NSMallocBlock__: 0x1006000c0&gt; 总结： 当block中没有引用任何外部变量时或者仅仅调用静态区变量时，编译器直接将block放在静态区(减少堆区的占用有利于性能的) copy 操作对将NSStackBlock拷贝到堆区、对另外两种类型只是强引用 arc下是没有NSStackBlock类型block的(block被当做对象处理) 附测试代码]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Block</tag>
      </tags>
  </entry>
</search>